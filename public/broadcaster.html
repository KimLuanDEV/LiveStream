<!doctype html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broadcaster - Livestream</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Segoe UI, Roboto, sans-serif; background:#0b1220; color:#e6f0ff; margin:0; padding:24px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    video { width: 640px; max-width:100%; background:#000; border-radius:12px; }
    button { padding:10px 16px; border:0; border-radius:10px; cursor:pointer; font-weight:600; }
    .start { background:#2ecc71; }
    .stop { background:#e74c3c; }
    .muted { background:#8e44ad; }
    .tag { background:#17203a; padding:6px 10px; border-radius:8px; font-size:12px; }
    #logs { background:#0e1730; border:1px solid #233056; border-radius:10px; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; max-height:220px; overflow:auto; }
    .warn { color:#f7d774 }
    .err  { color:#ff8a8a }
    .ok   { color:#8ff0a4 }
    label { display:flex; align-items:center; gap:8px; }
    select{ padding:6px 8px; border-radius:8px; background:#0e1730; color:#e6f0ff; border:1px solid #233056; }
  </style>
</head>
<body>
  <h1>üé• Broadcaster</h1>

  <div class="row">
    <button id="btnStart" class="start" disabled>B·∫Øt ƒë·∫ßu ph√°t</button>
    <button id="btnStartNoAudio" class="muted" disabled>Ph√°t (kh√¥ng mic)</button>
    <button id="btnFlip" class="muted" disabled>ƒê·ªïi camera</button>
    <button id="btnStop" class="stop" disabled>D·ª´ng ph√°t</button>
    <span id="status" class="tag">ƒêang kh·ªüi t·∫°o‚Ä¶</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label>Camera:
      <select id="selCam"></select>
    </label>
    <label>Mic:
      <select id="selMic"></select>
    </label>
    <span id="secureHint" class="tag"></span>
  </div>

  <p style="margin:8px 0 0">M·∫πo: Tr√™n ƒëi·ªán tho·∫°i, n·∫øu mu·ªën m·ªü m·∫∑c ƒë·ªãnh **camera sau**, b·∫•m ‚Äúƒê·ªïi camera‚Äù sau khi b·∫Øt ƒë·∫ßu ph√°t, ho·∫∑c ƒë·ªïi t·ª´ menu Camera tr∆∞·ªõc khi ph√°t.</p>

  <video id="preview" playsinline autoplay muted></video>

  <h3>Nh·∫≠t k√Ω</h3>
  <div id="logs"></div>

  <script>
    // ========== Helpers ==========
    const $ = (id) => document.getElementById(id);
    function log(msg, cls="") {
      const d = new Date().toLocaleTimeString();
      const el = document.createElement("div");
      if (cls) el.className = cls;
      el.textContent = `[${d}] ${msg}`;
      $("logs").appendChild(el);
      $("logs").scrollTop = $("logs").scrollHeight;
      console.log(msg);
    }

    // Secure-context hint
    const isSecure = location.protocol === "https:" || ["localhost","127.0.0.1"].includes(location.hostname);
    $("secureHint").textContent = isSecure
      ? "‚úÖ HTTPS/localhost: OK"
      : "‚ö†Ô∏è C·∫ßn HTTPS ƒë·ªÉ camera/mic ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh";

    // ========== WebSocket ==========
    const WS_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host;
    let ws, wsOpen = false;

    function setupWS() {
      ws = new WebSocket(WS_URL);

      ws.addEventListener("open", () => {
        wsOpen = true;
        $("status").textContent = "WS connected. S·∫µn s√†ng ph√°t.";
        $("btnStart").disabled = false;
        $("btnStartNoAudio").disabled = false;
        log("WebSocket: connected", "ok");
        listDevicesAndFill(); // sau khi c√≥ th·ªÉ xin quy·ªÅn
      });

      ws.addEventListener("close", () => {
        wsOpen = false;
        $("status").textContent = "WS disconnected";
        $("btnStart").disabled = true;
        $("btnStartNoAudio").disabled = true;
        $("btnFlip").disabled = true;
        log("WebSocket: closed", "warn");
      });

      ws.addEventListener("error", () => {
        log("WebSocket error (ki·ªÉm tra Render/proxy).", "err");
      });

      ws.addEventListener("message", async (ev) => {
        const msg = JSON.parse(ev.data);

        if (msg.type === "ack" && msg.role === "broadcaster") {
          log("Server ACK: broadcaster s·∫µn s√†ng.", "ok");
          $("status").textContent = "ƒêang ph√°t‚Ä¶ ch·ªù viewer";
        }

        if (msg.type === "viewer-join") {
          log(`Viewer join: ${msg.viewerId}`);
          createOfferForViewer(msg.viewerId);
        }

        if (msg.type === "answer") {
          const pc = peers.get(msg.viewerId);
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
            log(`ƒê√£ nh·∫≠n answer t·ª´ viewer ${msg.viewerId}`, "ok");
          }
        }

        if (msg.type === "ice-candidate") {
          const pc = peers.get(msg.viewerId);
          if (pc && msg.candidate) {
            try { await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch (e) { log("addIceCandidate error: " + e.message, "err"); }
          }
        }

        if (msg.type === "viewer-left") {
          const pc = peers.get(msg.viewerId);
          if (pc) { pc.close(); peers.delete(msg.viewerId); }
          log(`Viewer r·ªùi: ${msg.viewerId}`, "warn");
        }

        if (msg.type === "end") {
          log("Server y√™u c·∫ßu d·ª´ng ph√°t.", "warn");
          stopStream();
        }
      });
    }
    setupWS();

    // ========== Media & WebRTC ==========
    const peers = new Map(); // viewerId -> RTCPeerConnection
    let localStream = null;
    let isStreaming = false;
    let desiredFacing = "user";     // user|environment
    let currentCamDeviceId = null;

    const iceServers = [
      { urls: "stun:stun.l.google.com:19302" },
      // Th√™m TURN n·∫øu c·∫ßn NAT kh√≥:
      // { urls: "turn:YOUR_TURN:3478", username:"USER", credential:"PASS" }
    ];

    function makeVideoConstraints({ facing, deviceId }) {
      if (deviceId) return { video: { deviceId: { exact: deviceId } } };
      if (facing) return { video: { facingMode: { exact: facing } } };
      return { video: { width: { ideal: 1280 }, height: { ideal: 720 } } };
    }

    async function ensureWSReady() {
      if (wsOpen) return true;
      for (let i=0;i<30;i++) { await new Promise(r => setTimeout(r, 100)); if (wsOpen) return true; }
      log("WS ch∆∞a s·∫µn s√†ng. Kh√¥ng th·ªÉ ph√°t.", "err");
      return false;
    }

    async function listDevicesAndFill() {
      try {
        // k√≠ch ho·∫°t quy·ªÅn tr∆∞·ªõc ƒë·ªÉ hi·ªán label
        try {
          const tmp = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
          tmp.getTracks().forEach(t => t.stop());
        } catch(e) { /* user c√≥ th·ªÉ t·ª´ ch·ªëi l·∫ßn ƒë·∫ßu; v·∫´n enumerate ƒë∆∞·ª£c 1 ph·∫ßn */ }

        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === "videoinput");
        const mics = devices.filter(d => d.kind === "audioinput");

        const selCam = $("selCam"), selMic = $("selMic");
        selCam.innerHTML = ""; selMic.innerHTML = "";

        cams.forEach((d, i) => {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${i+1}`;
          selCam.appendChild(opt);
        });
        mics.forEach((d, i) => {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `Mic ${i+1}`;
          selMic.appendChild(opt);
        });

        log(`Thi·∫øt b·ªã: ${cams.length} camera, ${mics.length} mic.`, "ok");
      } catch (e) {
        log("enumerateDevices l·ªói: " + e.message, "err");
      }
    }

    async function startStream(withAudio = true) {
      const ok = await ensureWSReady();
      if (!ok) return;

      const selCam = $("selCam"), selMic = $("selMic");
      const camId = selCam && selCam.value ? selCam.value : undefined;
      const micId = selMic && selMic.value ? selMic.value : undefined;

      const trialConstraints = [];
      // ∆∞u ti√™n deviceId n·∫øu ƒë√£ ch·ªçn
      if (camId || (withAudio && micId)) {
        trialConstraints.push({
          video: camId ? { deviceId: { exact: camId } } : true,
          audio: withAudio ? (micId ? { deviceId: { exact: micId } } : true) : false
        });
      }
      // facingMode (mobile)
      trialConstraints.push({
        video: { facingMode: desiredFacing },
        audio: withAudio
      });
      // 720p m·ªÅm
      trialConstraints.push({
        video: { width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: withAudio
      });
      // r·∫•t r·ªông
      trialConstraints.push({ video: true, audio: withAudio });
      // video-only fallback
      trialConstraints.push({ video: true, audio: false });

      let stream = null, lastErr = null;
      for (const c of trialConstraints) {
        try {
          log("Th·ª≠ constraints: " + JSON.stringify(c));
          stream = await navigator.mediaDevices.getUserMedia(c);
          if (stream) break;
        } catch (e) { lastErr = e; }
      }
      if (!stream) {
        log("Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera/mic: " + (lastErr ? (lastErr.name + ": " + lastErr.message) : ""), "err");
        $("status").textContent = "Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera/mic.";
        return;
      }

      localStream = stream;
      $("preview").srcObject = localStream;

      // c·∫≠p nh·∫≠t deviceId hi·ªán t·∫°i (n·∫øu c√≥)
      const vtrack = localStream.getVideoTracks()[0];
      currentCamDeviceId = vtrack?.getSettings?.().deviceId || camId || null;

      try { ws.send(JSON.stringify({ type: "broadcaster-ready" })); }
      catch (e) { log("G·ª≠i broadcaster-ready th·∫•t b·∫°i: " + e.message, "err"); return; }

      isStreaming = true;
      $("btnStart").disabled = true;
      $("btnStartNoAudio").disabled = true;
      $("btnStop").disabled = false;
      $("btnFlip").disabled = false;
      $("status").textContent = "ƒêang ph√°t‚Ä¶ m·ªùi viewer m·ªü viewer.html";
      log("ƒê√£ b·∫Øt ƒë·∫ßu ph√°t.", "ok");
    }

    async function createOfferForViewer(viewerId) {
      if (!localStream) { log("Ch∆∞a c√≥ localStream khi viewer join.", "err"); return; }
      const pc = new RTCPeerConnection({ iceServers });
      peers.set(viewerId, pc);

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          ws.send(JSON.stringify({
            type: "ice-candidate", from:"broadcaster",
            viewerId, candidate: e.candidate
          }));
        }
      };
      pc.onconnectionstatechange = () => { /* log(`Peer ${viewerId}: ${pc.connectionState}`); */ };

      const offer = await pc.createOffer(); // KH√îNG truy·ªÅn offerToReceive*
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ type:"offer", viewerId, sdp: pc.localDescription }));
      log(`ƒê√£ g·ª≠i offer cho viewer ${viewerId}`, "ok");
    }

    function stopStream() {
      if (!isStreaming) return;
      for (const [, pc] of peers) pc.close();
      peers.clear();
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      isStreaming = false;
      $("preview").srcObject = null;
      $("btnStart").disabled = !wsOpen;
      $("btnStartNoAudio").disabled = !wsOpen;
      $("btnStop").disabled = true;
      $("btnFlip").disabled = true;
      $("status").textContent = "ƒê√£ d·ª´ng ph√°t";
      log("ƒê√£ d·ª´ng ph√°t & ƒë√≥ng peers.");
    }

    async function getCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d => d.kind === "videoinput");
    }

    async function switchCamera() {
      if (!isStreaming) { log("B·∫•m B·∫Øt ƒë·∫ßu ph√°t tr∆∞·ªõc khi ƒë·ªïi camera.", "warn"); return; }
      try {
        const nextFacing = desiredFacing === "user" ? "environment" : "user";
        let targetDeviceId = null;
        try {
          const cams = await getCameras();
          const guess = cams.find(c =>
            (nextFacing === "environment")
              ? /back|rear|environment|sau|ngo√†i/i.test(c.label)
              : /front|user|tr∆∞·ªõc|trong/i.test(c.label)
          );
          if (guess) targetDeviceId = guess.deviceId;
        } catch {}

        const constraints = makeVideoConstraints({ facing: nextFacing, deviceId: targetDeviceId });
        const newStream = await navigator.mediaDevices.getUserMedia({ ...constraints, audio:false });
        const newTrack = newStream.getVideoTracks()[0];
        if (!newTrack) throw new Error("Kh√¥ng l·∫•y ƒë∆∞·ª£c video track m·ªõi.");

        // local preview
        const oldVideoTracks = localStream.getVideoTracks();
        oldVideoTracks.forEach(t => t.stop());
        oldVideoTracks.forEach(t => localStream.removeTrack?.(t));
        localStream.addTrack(newTrack);
        $("preview").srcObject = null;
        $("preview").srcObject = localStream;

        // thay track tr√™n t·∫•t c·∫£ peer
        for (const [, pc] of peers) {
          const senders = pc.getSenders().filter(s => s.track && s.track.kind === "video");
          if (senders.length) {
            await Promise.all(senders.map(s => s.replaceTrack(newTrack)));
          } else {
            pc.addTrack(newTrack, localStream);
          }
        }

        desiredFacing = nextFacing;
        const settings = newTrack.getSettings?.();
        currentCamDeviceId = settings?.deviceId || targetDeviceId || null;

        log(`ƒê√£ ƒë·ªïi camera sang: ${desiredFacing}${currentCamDeviceId ? " ("+currentCamDeviceId+")" : ""}`, "ok");
      } catch (e) {
        log("ƒê·ªïi camera th·∫•t b·∫°i: " + e.message, "err");
      }
    }

    $("btnStart").onclick = () => startStream(true);
    $("btnStartNoAudio").onclick = () => startStream(false);
    $("btnStop").onclick  = stopStream;
    $("btnFlip").onclick  = switchCamera;

    document.addEventListener("DOMContentLoaded", () => {
      // n·∫øu WS ƒë√£ m·ªü th√¨ li·ªát k√™ thi·∫øt b·ªã; n·∫øu ch∆∞a, listDevicesAndFill s·∫Ω g·ªçi sau khi WS open
      if (wsOpen) listDevicesAndFill();
    });
  </script>
</body>
</html>
