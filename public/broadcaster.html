<!doctype html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broadcaster - Livestream</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Segoe UI, Roboto, sans-serif; background:#0b1220; color:#e6f0ff; margin:0; padding:24px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    video { width: 640px; max-width:100%; background:#000; border-radius:12px; }
    button { padding:10px 16px; border:0; border-radius:10px; cursor:pointer; font-weight:600; }
    .start { background:#2ecc71; }
    .stop { background:#e74c3c; }
    .muted { background:#8e44ad; }
    .tag { background:#17203a; padding:6px 10px; border-radius:8px; font-size:12px; }
    #logs { background:#0e1730; border:1px solid #233056; border-radius:10px; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; max-height:220px; overflow:auto; }
    .warn { color:#f7d774 }
    .err  { color:#ff8a8a }
    .ok   { color:#8ff0a4 }
    label { display:flex; align-items:center; gap:8px; }
    select{ padding:6px 8px; border-radius:8px; background:#0e1730; color:#e6f0ff; border:1px solid #233056; }
    input[type="checkbox"] { transform: scale(1.1); margin-right: 6px; }
  </style>
</head>
<body>
  <h1>üé• Broadcaster</h1>

  <div class="row">
    <button id="btnStart" class="start" disabled>B·∫Øt ƒë·∫ßu ph√°t</button>
    <button id="btnStartNoAudio" class="muted" disabled>Ph√°t (kh√¥ng mic)</button>
    <button id="btnFlip" class="muted" disabled>ƒê·ªïi camera</button>
    <button id="btnStop" class="stop" disabled>D·ª´ng ph√°t</button>
    <span id="status" class="tag">ƒêang kh·ªüi t·∫°o‚Ä¶</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label>Camera:
      <select id="selCam"></select>
    </label>
    <label>Mic:
      <select id="selMic"></select>
    </label>
    <label class="tag" style="cursor:pointer">
      <input type="checkbox" id="chkRelayOnly"> TURN-only (ch·∫©n ƒëo√°n)
    </label>
    <span id="secureHint" class="tag"></span>
  </div>

  <p style="margin:8px 0 0">M·∫πo: Tr√™n ƒëi·ªán tho·∫°i, n·∫øu mu·ªën m·ªü m·∫∑c ƒë·ªãnh <b>camera sau</b>, b·∫•m ‚Äúƒê·ªïi camera‚Äù sau khi b·∫Øt ƒë·∫ßu ph√°t, ho·∫∑c ch·ªçn camera t·ª´ menu tr∆∞·ªõc khi ph√°t.</p>

  <video id="preview" playsinline autoplay muted></video>

  <h3>Nh·∫≠t k√Ω</h3>
  <div id="logs"></div>

  <script>
    const $ = (sel) => sel && sel.startsWith("#") ? document.querySelector(sel) : document.getElementById(sel);
    function log(msg, cls="") {
      const d = new Date().toLocaleTimeString();
      const el = document.createElement("div");
      if (cls) el.className = cls;
      el.textContent = `[${d}] ${msg}`;
      $("#logs").appendChild(el);
      $("#logs").scrollTop = $("#logs").scrollHeight;
      console.log(msg);
    }

    const isSecure = location.protocol === "https:" || ["localhost","127.0.0.1"].includes(location.hostname);
    $("#secureHint").textContent = isSecure
      ? "‚úÖ HTTPS/localhost: OK"
      : "‚ö†Ô∏è C·∫ßn HTTPS ƒë·ªÉ camera/mic ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh";

    // ===== Load ICE from /ice (Twilio) + ∆∞u ti√™n 443 =====
    let iceServers = [{ urls: "stun:stun.l.google.com:19302" }]; // fallback
    async function loadIceServers() {
      try {
        const r = await fetch("/ice", { cache: "no-store" });
        const d = await r.json();
        if (Array.isArray(d.iceServers) && d.iceServers.length) {
          iceServers = d.iceServers;

  // ---- ∆ØU TI√äN TLS/443 cho m·∫°ng di ƒë·ªông (5G) ----
  const anyTurn = iceServers.find(s => String(s.urls||s.url||'').includes('turn'));
  const has443 = iceServers.some(s => String(s.urls||s.url||'').includes(':443'));
  if (anyTurn && !has443) {
    iceServers.push({
      urls: "turns:global.turn.twilio.com:443?transport=tcp",
      username: anyTurn.username,
      credential: anyTurn.credential
    });
  }
  const score = u =>
    u.includes('turns:') && u.includes(':443') ? 0 :
    u.includes('turns:') && u.includes(':5349') ? 1 :
    u.includes('turn:')  && u.includes('transport=tcp') ? 2 :
    u.includes('turn:')  ? 3 :
    u.includes('stun:')  ? 4 : 5;
  iceServers = iceServers
    .flatMap(s => {
      const urls = Array.isArray(s.urls) ? s.urls : [s.urls || s.url].filter(Boolean);
      return urls.map(url => ({ urls: url, username: s.username, credential: s.credential }));
    })
    .sort((a,b) => score(String(a.urls)) - score(String(b.urls)));

          log("ƒê√£ t·∫£i ICE (Twilio) & ∆∞u ti√™n turns:443.", "ok");
        } else {
          log("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c danh s√°ch ICE t·ª´ /ice. D√πng STUN fallback.", "warn");
        }
      } catch (e) {
        log("Fetch /ice l·ªói. D√πng STUN fallback.", "warn");
      }
    }

    
        const WS_SCHEME = (location.protocol === 'https:' ? 'wss' : 'ws');
    const WS_ORIGIN = WS_SCHEME + '://' + location.host;
    let ws = null;
    let wsOpen = false;
    let wsReconnectDelay = 500; // ms
    const WS_RECONNECT_MAX = 8000;

    function setupWS() {
      tryConnectWS();
    }

    function tryConnectWS() {
      const url = WS_ORIGIN;
      ws = new WebSocket(url);
      ws.addEventListener("open", () => {
        wsOpen = true;
        wsReconnectDelay = 500;
        log("WebSocket connected: " + url, "ok");
        const statusEl = document.getElementById("status");
        if (statusEl) statusEl.textContent = "WS connected.";
        // enable UI if broadcaster
        if (true) {
          document.getElementById("btnStart").disabled = false;
          document.getElementById("btnStartNoAudio").disabled = false;
          listDevicesAndFill();
        }
      });
      ws.addEventListener("close", (ev) => {
        wsOpen = false;
        log("WebSocket closed (" + ev.code + "): " + (ev.reason || "no reason"), "warn");
        const statusEl = document.getElementById("status");
        if (statusEl) statusEl.textContent = "WS disconnected (" + ev.code + "). Reconnecting‚Ä¶";
        // disable UI if broadcaster
        if (true) {
          document.getElementById("btnStart").disabled = true;
          document.getElementById("btnStartNoAudio").disabled = true;
          document.getElementById("btnFlip").disabled = true;
        }
        setTimeout(tryConnectWS, wsReconnectDelay);
        wsReconnectDelay = Math.min(WS_RECONNECT_MAX, Math.floor(wsReconnectDelay * 1.7));
      });
      ws.addEventListener("error", (e) => {
        log("WebSocket error (proxy/SSL?): " + (e.message || e), "err");
        ws.close();
      });
      ws.addEventListener("message", async (ev) => {
        const msg = JSON.parse(ev.data);
                if (msg.type === "ack" && msg.role === "broadcaster") {
          log("Server ACK: broadcaster s·∫µn s√†ng.", "ok");
          document.getElementById("status").textContent = "ƒêang ph√°t‚Ä¶ ch·ªù viewer";
        }
        if (msg.type === "viewer-join") {
          log(`Viewer join: ${msg.viewerId}`);
          createOfferForViewer(msg.viewerId);
        }
        if (msg.type === "answer") {
          const pc = peers.get(msg.viewerId);
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
            log(`ƒê√£ nh·∫≠n answer t·ª´ viewer ${msg.viewerId}`, "ok");
          }
        }
        if (msg.type === "ice-candidate") {
          const pc = peers.get(msg.viewerId);
          if (pc && msg.candidate) {
            try { await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch (e) { log("addIceCandidate error: " + e.message, "err"); }
          }
        }
        if (msg.type === "viewer-left") {
          const pc = peers.get(msg.viewerId);
          if (pc) { pc.close(); peers.delete(msg.viewerId); }
          log(`Viewer r·ªùi: ${msg.viewerId}`, "warn");
        }
        if (msg.type === "end") {
          log("Server y√™u c·∫ßu d·ª´ng ph√°t.", "warn");
          stopStream();
        }
    
      });
    }
    

const peers = new Map();
setupWS();
    let localStream = null;
    let isStreaming = false;
    let desiredFacing = "user";
    let currentCamDeviceId = null;

    function makeVideoConstraints({ facing, deviceId }) {
      if (deviceId) return { video: { deviceId: { exact: deviceId } } };
      if (facing) return { video: { facingMode: { exact: facing } } };
      return { video: { width: { ideal: 1280 }, height: { ideal: 720 } } };
    }

    async function ensureWSReady() {
      if (wsOpen) return true;
      for (let i=0;i<30;i++) { await new Promise(r => setTimeout(r, 100)); if (wsOpen) return true; }
      log("WS ch∆∞a s·∫µn s√†ng. Kh√¥ng th·ªÉ ph√°t.", "err");
      return false;
    }

    async function listDevicesAndFill() {
      try {
        try {
          const tmp = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
          tmp.getTracks().forEach(t => t.stop());
        } catch(e) {}
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === "videoinput");
        const mics = devices.filter(d => d.kind === "audioinput");
        const selCam = $("#selCam"), selMic = $("#selMic");
        selCam.innerHTML = ""; selMic.innerHTML = "";
        cams.forEach((d, i) => {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${i+1}`;
          selCam.appendChild(opt);
        });
        mics.forEach((d, i) => {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `Mic ${i+1}`;
          selMic.appendChild(opt);
        });
        log(`Thi·∫øt b·ªã: ${cams.length} camera, ${mics.length} mic.`, "ok");
      } catch (e) {
        log("enumerateDevices l·ªói: " + e.message, "err");
      }
    }

    async function startStream(withAudio = true) {
      const ok = await ensureWSReady();
      if (!ok) return;
      await loadIceServers(); // l·∫•y ICE Twilio + ∆∞u ti√™n 443

      const selCam = $("#selCam"), selMic = $("#selMic");
      const camId = selCam && selCam.value ? selCam.value : undefined;
      const micId = selMic && selMic.value ? selMic.value : undefined;

      const trials = [];
      if (camId || (withAudio && micId)) {
        trials.push({ video: camId ? { deviceId: { exact: camId } } : true, audio: withAudio ? (micId ? { deviceId: { exact: micId } } : true) : false });
      }
      trials.push({ video: { facingMode: desiredFacing }, audio: withAudio });
      const isCellular = navigator.connection && /cellular/i.test(navigator.connection.type || navigator.connection.effectiveType || "");
      const baseVideo = isCellular ? { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { ideal: 24, max: 30 } } : { width: { ideal: 1280 }, height: { ideal: 720 } };
      trials.push({ video: baseVideo, audio: withAudio });
      trials.push({ video: true, audio: withAudio });
      trials.push({ video: true, audio: false });

      let stream = null, lastErr = null;
      for (const c of trials) {
        try { log("Th·ª≠ constraints: " + JSON.stringify(c)); stream = await navigator.mediaDevices.getUserMedia(c); if (stream) break; }
        catch (e) { lastErr = e; }
      }
      if (!stream) {
        log("Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera/mic: " + (lastErr ? (lastErr.name + ": " + lastErr.message) : ""), "err");
        $("#status").textContent = "Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera/mic.";
        return;
      }
      localStream = stream;
      $("#preview").srcObject = localStream;

      const vtrack = localStream.getVideoTracks()[0];
      currentCamDeviceId = vtrack?.getSettings?.().deviceId || camId || null;

      try { ws.send(JSON.stringify({ type: "broadcaster-ready" })); }
      catch (e) { log("G·ª≠i broadcaster-ready th·∫•t b·∫°i: " + e.message, "err"); return; }

      isStreaming = true;
      $("#btnStart").disabled = true;
      $("#btnStartNoAudio").disabled = true;
      $("#btnStop").disabled = false;
      $("#btnFlip").disabled = false;
      $("#status").textContent = "ƒêang ph√°t‚Ä¶ ch·ªù viewer";
      log("ƒê√£ b·∫Øt ƒë·∫ßu ph√°t.", "ok");
    }

    async function logSelectedCandidatePair(pc) {
      try {
        const stats = await pc.getStats();
        stats.forEach(report => {
          if (report.type === "transport" && report.selectedCandidatePairId) {
            const pair = stats.get(report.selectedCandidatePairId);
            const local = stats.get(pair.localCandidateId);
            const remote = stats.get(pair.remoteCandidateId);
            log("Selected pair -> local: " + local.candidateType + "/" + local.protocol + " " + (local.ip||local.address) + ":" + local.port);
            log("Selected pair -> remote: " + remote.candidateType + "/" + remote.protocol + " " + (remote.ip||remote.address) + ":" + remote.port);
          }
        });
      } catch {}
    }

    async function createOfferForViewer(viewerId) {
      if (!localStream) { log("Ch∆∞a c√≥ localStream khi viewer join.", "err"); return; }
      const userRelayOnly = document.getElementById("chkRelayOnly")?.checked;
      const isCellular = navigator.connection && /cellular/i.test(navigator.connection.type || navigator.connection.effectiveType || "");
      const forceRelay = userRelayOnly || isCellular; // auto relay tr√™n m·∫°ng di ƒë·ªông

      const pc = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy: forceRelay ? "relay" : "all"
      });
      peers.set(viewerId, pc);

      pc.oniceconnectionstatechange = () => {
        log("ICE state ("+viewerId+"): " + pc.iceConnectionState);
        if (pc.iceConnectionState === "connected" || pc.iceConnectionState === "completed") {
          setTimeout(() => logSelectedCandidatePair(pc), 1500);
        }
      };

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      // === GI·ªöI H·∫†N BITRATE / ∆ØU TI√äN MOBILE ===
      try {
        const isCell = navigator.connection && /cellular/i.test(navigator.connection.type || navigator.connection.effectiveType || "");
        const senders = pc.getSenders ? pc.getSenders() : [];
        const vsender = senders.find(s => s.track && s.track.kind === "video");
        if (vsender?.getParameters) {
          const p = vsender.getParameters();
          p.degradationPreference = "balanced";
          const maxKbps = isCell ? 800 : 1500;
          p.encodings = p.encodings && p.encodings.length ? p.encodings : [{}];
          p.encodings[0].maxBitrate = maxKbps * 1000;
          await vsender.setParameters(p);
          if (vsender.track) vsender.track.contentHint = "motion";
          console.log("Video max bitrate:", maxKbps, "kbps");
        }
      } catch (e) { console.warn("setParameters fail:", e); }


      pc.onicecandidate = (e) => {
        if (e.candidate) {
          ws.send(JSON.stringify({ type: "ice-candidate", from:"broadcaster", viewerId, candidate: e.candidate }));
        }
      };


      // === ∆ØU TI√äN CODEC: H.264 (video), Opus (audio) ===
      try {
        if (pc.getTransceivers) {
          const txv = pc.getTransceivers().find(t => t.sender?.track?.kind === "video");
          if (txv?.setCodecPreferences && window.RTCRtpSender?.getCapabilities) {
            const capsV = RTCRtpSender.getCapabilities("video");
            if (capsV?.codecs?.length) {
              const h264 = capsV.codecs.filter(c => /H264/i.test(c.mimeType));
              const others = capsV.codecs.filter(c => !/H264/i.test(c.mimeType));
              const prefsV = [...h264, ...others];
              txv.setCodecPreferences(prefsV);
              console.log("Codec prefs (video):", prefsV.map(c => c.mimeType));
            }
          }
          const txa = pc.getTransceivers().find(t => t.sender?.track?.kind === "audio");
          if (txa?.setCodecPreferences && window.RTCRtpSender?.getCapabilities) {
            const capsA = RTCRtpSender.getCapabilities("audio");
            if (capsA?.codecs?.length) {
              const opus = capsA.codecs.filter(c => /opus/i.test(c.mimeType));
              const othersA = capsA.codecs.filter(c => !/opus/i.test(c.mimeType));
              const prefsA = [...opus, ...othersA];
              txa.setCodecPreferences(prefsA);
              console.log("Codec prefs (audio):", prefsA.map(c => c.mimeType));
            }
          }
        }
      } catch (e) { console.warn("setCodecPreferences fail:", e); }

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ type:"offer", viewerId, sdp: pc.localDescription }));
      log(`ƒê√£ g·ª≠i offer cho viewer ${viewerId}`, "ok");
    }

    function stopStream() {
      if (!isStreaming) return;
      for (const [, pc] of peers) pc.close();
      peers.clear();
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      isStreaming = false;
      $("#preview").srcObject = null;
      $("#btnStart").disabled = !wsOpen;
      $("#btnStartNoAudio").disabled = !wsOpen;
      $("#btnStop").disabled = true;
      $("#btnFlip").disabled = true;
      $("#status").textContent = "ƒê√£ d·ª´ng ph√°t";
      log("ƒê√£ d·ª´ng ph√°t & ƒë√≥ng peers.");
    }

    async function getCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d => d.kind === "videoinput");
    }

    async function switchCamera() {
      if (!isStreaming) { log("B·∫•m B·∫Øt ƒë·∫ßu ph√°t tr∆∞·ªõc khi ƒë·ªïi camera.", "warn"); return; }
      try {
        const nextFacing = desiredFacing === "user" ? "environment" : "user";
        let targetDeviceId = null;
        try {
          const cams = await getCameras();
          const guess = cams.find(c =>
            (nextFacing === "environment")
              ? /back|rear|environment|sau|ngo√†i/i.test(c.label)
              : /front|user|tr∆∞·ªõc|trong/i.test(c.label)
          );
          if (guess) targetDeviceId = guess.deviceId;
        } catch {}

        const constraints = makeVideoConstraints({ facing: nextFacing, deviceId: targetDeviceId });
        const newStream = await navigator.mediaDevices.getUserMedia({ ...constraints, audio:false });
        const newTrack = newStream.getVideoTracks()[0];
        if (!newTrack) throw new Error("Kh√¥ng l·∫•y ƒë∆∞·ª£c video track m·ªõi.");

        const oldVideoTracks = localStream.getVideoTracks();
        oldVideoTracks.forEach(t => t.stop());
        oldVideoTracks.forEach(t => localStream.removeTrack?.(t));
        localStream.addTrack(newTrack);
        $("#preview").srcObject = null;
        $("#preview").srcObject = localStream;

        for (const [, pc] of peers) {
          const senders = pc.getSenders().filter(s => s.track && s.track.kind === "video");
          if (senders.length) {
            await Promise.all(senders.map(s => s.replaceTrack(newTrack)));
          } else {
            pc.addTrack(newTrack, localStream);
          }
        }

        desiredFacing = nextFacing;
        const settings = newTrack.getSettings?.();
        currentCamDeviceId = settings?.deviceId || targetDeviceId || null;

        log(`ƒê√£ ƒë·ªïi camera sang: ${desiredFacing}${currentCamDeviceId ? " ("+currentCamDeviceId+")" : ""}`, "ok");
      } catch (e) {
        log("ƒê·ªïi camera th·∫•t b·∫°i: " + e.message, "err");
      }
    }

    $("#btnStart").onclick = () => startStream(true);
    $("#btnStartNoAudio").onclick = () => startStream(false);
    $("#btnStop").onclick  = stopStream;
    $("#btnFlip").onclick  = switchCamera;

    document.addEventListener("DOMContentLoaded", () => { /* devices filled after WS open */ });
  </script>
</body>
</html>
